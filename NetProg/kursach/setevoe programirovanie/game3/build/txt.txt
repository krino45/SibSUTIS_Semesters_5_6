chat related code:

void Game::toggleChat()
{
    if (chatActive)
        return;

    chatActive = true;
    inputHandler.startChatMode();

    std::thread([this]() {
        std::string message = inputHandler.getChatInput();
        if (!message.empty())
        {
            networkManager.sendChatMessage(message);
            addChatMessage("You", message);
            renderer.renderChatMessages(getChatMessages());
        }
        chatActive = false;
        inputHandler.stopChatMode();
    }).detach();
}

void Game::addChatMessage(const std::string &sender, const std::string &message)
{
    // Create a new chat message
    ChatMessageData chatMsg;
    strncpy(chatMsg.sender, sender.c_str(), sizeof(chatMsg.sender) - 1);
    chatMsg.sender[sizeof(chatMsg.sender) - 1] = '\0';
    strncpy(chatMsg.content, message.c_str(), sizeof(chatMsg.content) - 1);
    chatMsg.content[sizeof(chatMsg.content) - 1] = '\0';
    chatMsg.timestamp = static_cast<uint32_t>(time(nullptr));
    chatMsg.contentLength = message.length();

    // Add to the chat messages vector
    chatMessages.push_back(chatMsg);

    // Limit the number of messages to display (keep the most recent ones)
    const size_t MAX_MESSAGES = 5;
    if (chatMessages.size() > MAX_MESSAGES)
    {
        chatMessages.erase(chatMessages.begin(), chatMessages.begin() + (chatMessages.size() - MAX_MESSAGES));
    }
}

const std::vector<ChatMessageData> &Game::getChatMessages() const
{
    return chatMessages;
}

// also refactor the following ones to use terminal:: namespace

void InputHandler::startChatMode()
{
    chatMode = true;
    currentChatInput = "";

    // Switch to blocking mode for chat
    int flags = fcntl(STDIN_FILENO, F_GETFL, 0);
    fcntl(STDIN_FILENO, F_SETFL, flags & ~O_NONBLOCK);
}

void InputHandler::stopChatMode()
{
    chatMode = false;

    // Switch back to non-blocking mode
    int flags = fcntl(STDIN_FILENO, F_GETFL, 0);
    fcntl(STDIN_FILENO, F_SETFL, flags | O_NONBLOCK);
}

std::string InputHandler::getChatInput()
{
    if (!chatMode)
        return "";

    // Save terminal settings
    struct termios oldt, newt;
    tcgetattr(STDIN_FILENO, &oldt);
    newt = oldt;

    // Enable echo and canonical mode for chat input
    disableRawMode();
    terminal::showCursor();
    newt.c_lflag |= (ECHO | ICANON);
    tcsetattr(STDIN_FILENO, TCSANOW, &newt);

    // Get the input
    std::string input;
    std::getline(std::cin, input);

    // Restore raw mode settings
    tcsetattr(STDIN_FILENO, TCSANOW, &oldt);

    // Return the input
    return input;
}
        networkManager.onMatchFound = [&](const pong::ConnectResponse &response) {
            game->setOpponentInfo(response);
            if (response.isPlayer1)
            {
                networkManager.startChatServer(game->tcpPort);
                std::this_thread::sleep_for(std::chrono::milliseconds(1000));
            }
            else
            {
                std::this_thread::sleep_for(std::chrono::milliseconds(1000));
                networkManager.connectToChat(response.hostAddress, response.hostTcpPort);
            }
            // std::cout << "\n\nDebug: " << response.hostAddress << response.hostTcpPort << response.hostUdpPort
            //   << response.opponentName << response.success << response.isPlayer1 << std::flush;

            renderer.initializeChatArea(response.opponentName);
            std::this_thread::sleep_for(std::chrono::milliseconds(1000));
            game->getRenderer().showMatchFoundAnimation(response.opponentName);
        };

        networkManager.onScoreEvent = [game](const pong::ScoreEvent &event) {
            game->getRenderer().renderGoalAnimation();
        };

        networkManager.onVictoryEvent = [game](const pong::VictoryEvent &event) {
            game->getInputHandler().disableRawMode();
            game->getRenderer().showVictoryScreen(event.winnerName, event.player1Score, event.player2Score);
            game->getInputHandler().forceQuit();
            pong::ConnectResponse empty{};
            game->setOpponentInfo(empty);
        };

        networkManager.onDisconnectEvent = [&]() {
            pong::ConnectResponse empty{};
            game->getRenderer().showDisconnectMessage();
            game->setOpponentInfo(empty);
            game->getInputHandler().forceQuit();
            networkManager.stopChat();
        };

        networkManager.onChatMessage = [&](const pong::ChatMessageData &message) {
            game->addChatMessage(message.sender, message.content);
            renderer.renderChatMessages(game->getChatMessages());
        };

        while (choice != "1" && choice != "2")
        {
            networkManager.processCallbacks();
            if (game->ready)
            {
                break;
            }
            std::this_thread::sleep_for(std::chrono::milliseconds(64));
        }

        renderer.initialize();
        game->start();
        game->running = true;

        // Main game loop using the same instance
        while (game->running)
        {
            game->update();
            renderer.renderGameState(game->getGameState());
            std::this_thread::sleep_for(std::chrono::milliseconds(16));
        }
    }
    return 0;
}

NetworkManager::~NetworkManager()
{
    running = false;

    // Force wakeup the network thread if it's blocked in recvfrom
    if (udpSocket != -1)
    {
        shutdown(udpSocket, SHUT_RDWR);

        // Send a dummy packet to unblock recvfrom
        if (serverAddr.sin_port != 0)
        { // If we have a server address
            sendto(udpSocket, "", 0, 0, (struct sockaddr *)&serverAddr, sizeof(serverAddr));
        }
    }

    if (tcpSocket != -1)
    {
        shutdown(tcpSocket, SHUT_RDWR);
        close(tcpSocket);
        tcpSocket = -1;
    }

    if (listenThread.joinable())
    {
        listenThread.join();
    }

    if (chatThread.joinable())
    {
        chatThread.join();
    }

    if (udpSocket != -1)
    {
        close(udpSocket);
        udpSocket = -1;
    }
bool NetworkManager::startChatServer(uint16_t port)
{
    tcpSocket = socket(AF_INET, SOCK_STREAM, 0);
    if (tcpSocket == -1)
    {
        perror("chat socket");
        return false;
    }

    sockaddr_in serverAddr{};
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_port = htons(port);
    serverAddr.sin_addr.s_addr = INADDR_ANY;

    if (bind(tcpSocket, (struct sockaddr *)&serverAddr, sizeof(serverAddr)))
    {
        perror("chat bind");
        close(tcpSocket);
        return false;
    }

    if (listen(tcpSocket, 10))
    {
        perror("chat listen");
        close(tcpSocket);
        return false;
    }

    chatRunning = true;
    chatThread = std::thread([this]() {
        sockaddr_in clientAddr{};
        socklen_t clientLen = sizeof(clientAddr);
        int clientSocket = accept(tcpSocket, (struct sockaddr *)&clientAddr, &clientLen);

        if (clientSocket < 0)
        {
            perror("chat accept");
            return;
        }

        std::vector<uint8_t> buffer(1024);
        while (chatRunning)
        {
            ssize_t bytes = recv(clientSocket, buffer.data(), buffer.size(), 0);
            if (bytes <= 0)
            {
                if (bytes == 0)
                {
                    std::cerr << "Connection closed by peer." << std::endl;
                }
                else
                {
                    std::cerr << "recv error: " << strerror(errno) << std::endl;
                }
                break;
            }

            std::lock_guard<std::mutex> lock(chatMutex);
            ChatMessageData *message = reinterpret_cast<ChatMessageData *>(buffer.data());
            chatMessages.push_back(*message);
        }
        close(clientSocket);
    });

    return true;
}

bool NetworkManager::connectToChat(const std::string &address, uint16_t port)
{
    tcpSocket = socket(AF_INET, SOCK_STREAM, 0);
    if (tcpSocket == -1)
    {
        perror("chat socket");
        return false;
    }

    sockaddr_in serverAddr{};
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_port = htons(port);
    inet_pton(AF_INET, address.c_str(), &serverAddr.sin_addr);

    if (connect(tcpSocket, (struct sockaddr *)&serverAddr, sizeof(serverAddr)))
    {
        perror("chat connect");
        close(tcpSocket);
        return false;
    }

    chatRunning = true;
    chatThread = std::thread([this]() {
        std::vector<uint8_t> buffer(1024);
        while (chatRunning)
        {
            ssize_t bytes = recv(tcpSocket, buffer.data(), buffer.size(), 0);
            if (bytes <= 0)
            {
                if (bytes == 0)
                {
                    std::cerr << "Connection closed by peer." << std::endl;
                }
                else
                {
                    std::cerr << "recv error: " << strerror(errno) << std::endl;
                }
                break;
            }
            std::lock_guard<std::mutex> lock(chatMutex);
            ChatMessageData *message = reinterpret_cast<ChatMessageData *>(buffer.data());
            chatMessages.push_back(*message);
        }
    });

    return true;
}

void NetworkManager::sendChatMessage(const std::string &message_text)
{
    if (tcpSocket != -1)
    {
        std::vector<uint8_t> packet = createChatPacket(username, message_text);
        std::cout << "Sending to tcpSocket on " << tcpSocket << "\n" << std::flush;
        ssize_t bytesSent = send(tcpSocket, packet.data(), packet.size(), MSG_NOSIGNAL);
        if (bytesSent <= 0)
        {
            if (bytesSent == 0)
            {
                std::cerr << "Connection closed by peer." << std::endl;
            }
            else
            {
                std::cerr << "send error: " << strerror(errno) << std::endl;
            }
        }
    }
    else
    {
        std::cerr << "TCP socket is not open!" << std::endl;
        return;
    }
}

std::vector<ChatMessageData> NetworkManager::getChatMessages()
{
    std::lock_guard<std::mutex> lock(chatMutex);
    return chatMessages;
}

void NetworkManager::stopChat()
{
    chatRunning = false;
    if (tcpSocket != -1)
    {
        shutdown(tcpSocket, SHUT_RDWR);
        close(tcpSocket);
        tcpSocket = -1;
    }
    if (chatThread.joinable())
    {
        chatThread.join();
    }
}

void Renderer::drawChatArea()
{
    std::lock_guard<std::recursive_mutex> lock(renderMutex);

    for (int y = height + 6; y < height + 11; ++y)
    {
        terminal::setCursor(2, y);
        std::cout << "                    ";
    }
}
void Renderer::renderChatInput(const std::string &inputText)
{
    std::lock_guard<std::recursive_mutex> lock(renderMutex);

    terminal::setCursor(2, height + 11);
    std::cout << "> " << inputText;
}

void Renderer::initializeChatArea(const std::string &opponentName)
{
    std::lock_guard<std::recursive_mutex> lock(renderMutex);

    terminal::setCursor(2, height + 6);
    std::cout << getColoredText("--- CHAT WITH " + opponentName + " ---", 245) << std::flush;
}
void Renderer::renderChatMessages(const std::vector<ChatMessageData> &messages)
{
    drawChatArea();
    std::lock_guard<std::recursive_mutex> lock(renderMutex);

    int startY = height + 6;
    for (size_t i = 0; i < messages.size() && i < 5; ++i)
    {
        terminal::setCursor(2, startY + i);
        std::cout << messages[i].sender << ": " << messages[i].content;
    }
}

std::vector<uint8_t> createChatPacket(const std::string &sender, const std::string &message)
{
    // Calculate total size needed for chat message
    uint16_t contentLength = static_cast<uint16_t>(message.size());
    uint32_t totalSize = sizeof(ChatMessageData) + contentLength;

    // Create the buffer for the chat message
    std::vector<uint8_t> chatData(totalSize);
    ChatMessageData *chatMsg = reinterpret_cast<ChatMessageData *>(chatData.data());

    // Get current timestamp
    auto now = std::chrono::system_clock::now();
    uint32_t timestamp = std::chrono::duration_cast<std::chrono::seconds>(now.time_since_epoch()).count();

    // Fill chat message header
    strncpy(chatMsg->sender, sender.c_str(), sizeof(chatMsg->sender) - 1);
    chatMsg->sender[sizeof(chatMsg->sender) - 1] = '\0'; // Ensure null termination
    chatMsg->timestamp = timestamp;
    chatMsg->contentLength = contentLength;

    // Copy message content
    if (contentLength > 0)
    {
        memcpy(chatData.data() + sizeof(ChatMessageData), message.c_str(), contentLength);
    }

    // Create the complete packet
    return createPacket(MessageType::CHAT_MESSAGE, 0, chatData.data(), totalSize);
}
struct ChatMessageData
{
    char sender[32];
    uint32_t timestamp;
    uint16_t contentLength;
    char content[1024];
};

namespace pong
{

// Terminal control utilities
namespace terminal
{
inline void clearScreen()
{
    std::cout << "\033[2J\033[H";
}

inline void setCursor(int x, int y)
{
    std::cout << "\033[" << y << ";" << x << "H";
}

inline void hideCursor()
{
    std::cout << "\033[?25l";
}

inline void showCursor()
{
    std::cout << "\033[?25h";
}

inline void resetColor()
{
    std::cout << "\033[0m";
}

inline std::string colorText(const std::string &text, int fg, int bg = -1)
{
    std::stringstream ss;
    ss << "\033[38;5;" << fg << "m";
    if (bg >= 0)
    {
        ss << "\033[48;5;" << bg << "m";
    }
    ss << text << "\033[0m";
    return ss.str();
}
} // namespace terminal